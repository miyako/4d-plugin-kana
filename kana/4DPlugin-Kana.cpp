/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Kana.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Kana
 #	author : miyako
 #	2020/06/01
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Kana.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Kana
            
			case 1 :
				Convert_kana(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef enum {
 
    kana_convert_mode_hiragana = 0,
    kana_convert_mode_katagana = 2
    
}kana_convert_mode_t;

typedef enum {
 
    kana_convert_width_full = 0,
    kana_convert_width_half = 1
    
}kana_convert_width_t;

void Convert_kana(PA_PluginParameters params) {

    PA_long32 mode = PA_GetLongParameter(params, 2);

	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;

	C_TEXT returnValue;

#if VERSIONWIN
    
    PA_Unistring *u = PA_GetStringParameter(params, 1);
    
    DWORD dwMapFlags = 0;
    
    if(mode & kana_convert_mode_katagana) {
        dwMapFlags |= LCMAP_KATAKANA;
    }else{
        dwMapFlags |= LCMAP_HIRAGANA;
    }
    
    if(mode & kana_convert_width_half) {
        dwMapFlags |= LCMAP_HALFWIDTH;
    }else{
        dwMapFlags |= LCMAP_FULLWIDTH;
    }
    
    if(u) {
        std::wstring str = std::wstring((const wchar_t *)u->fString, u->fLength);
        
		int requestBufLen = LCMapStringEx(
			LOCALE_NAME_USER_DEFAULT,
			dwMapFlags,
			str.c_str(),
			str.length(),
			nullptr,
			0,
			nullptr,
			nullptr,
			0
		);

        std::vector<wchar_t> buf(++requestBufLen);
        
		if (LCMapStringEx(
			LOCALE_NAME_USER_DEFAULT,
			dwMapFlags,
			str.c_str(),
			str.length(),
			buf.data(),
			buf.size(),
			nullptr,
			nullptr,
			0
		)) {
			CUTF16String u16((const PA_Unichar *)buf.data());
			returnValue.setUTF16String(&u16);
		}
    }
#else
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    NSString *sourceText = Param1.copyUTF16String();
    
    NSMutableString *outputText = [sourceText mutableCopy];
    
    if(mode & kana_convert_mode_katagana) {
        CFStringTransform((CFMutableStringRef)outputText,
                          NULL,
                          CFSTR("[:^Modifier Letter:];Hiragana-Katakana"),
                          false);
    }else{
        CFStringTransform((CFMutableStringRef)outputText,
                          NULL,
                          CFSTR("[:^Modifier Letter:];Katakana-Hiragana"),
                          false);
    }
    
    if(mode & kana_convert_width_half) {
        CFStringTransform((CFMutableStringRef)outputText,
                          NULL,
                          kCFStringTransformFullwidthHalfwidth,
                          false);
    }else{
        CFStringTransform((CFMutableStringRef)outputText,
                          NULL,
                          kCFStringTransformFullwidthHalfwidth,
                          true);
    }
    
    returnValue.setUTF16String(outputText);
    [outputText release];
    [sourceText release];
    
#endif

	returnValue.setReturn(pResult);
}

